<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Trie: trie_interactive.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Trie
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">trie_interactive.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>This example shows the usage of various trie operations</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Copyright (c) 2012, Ranjith TV</span>
<span class="comment"> * All rights reserved.</span>
<span class="comment"> *</span>
<span class="comment"> * Licensed under the BSD 3-Clause (&quot;BSD New&quot; or &quot;BSD Simplified&quot;) license.</span>
<span class="comment"> * You may obtain a copy of the License at</span>
<span class="comment"> *</span>
<span class="comment"> * http://www.opensource.org/licenses/BSD-3-Clause</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &quot;trie.h&quot;</span>

<span class="keyword">class </span>TrieCaseInsensitiveCompare
{
<span class="keyword">public</span>:
    <span class="keywordtype">bool</span> operator()(<span class="keywordtype">char</span> v1, <span class="keywordtype">char</span> v2) {
        <span class="keywordtype">int</span> i1 = std::tolower(v1);
        <span class="keywordtype">int</span> i2 = std::tolower(v2);
        <span class="keywordflow">return</span> i1 &lt; i2;
    }
};
<span class="keyword">const</span> std::pair&lt;std::string, std::string&gt; sampleValues[] = {
            std::make_pair(std::string(<span class="stringliteral">&quot;Array&quot;</span>), std::string(<span class="stringliteral">&quot;Arrays are fixed-size sequence containers: they hold a specific number of elements ordered in a strict linear sequence&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Bitset&quot;</span>), std::string(<span class="stringliteral">&quot;A bitset is a special container class that is designed to store bits&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Deque&quot;</span>), std::string(<span class="stringliteral">&quot;Double-ended queue&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;List&quot;</span>), std::string(<span class="stringliteral">&quot;Lists are a kind of sequence container. As such, their elements are ordered following a linear sequence&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Map&quot;</span>), std::string(<span class="stringliteral">&quot;Maps are a kind of associative container that stores elements formed by the combination of a key value and a mapped value&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Maps&quot;</span>), std::string(<span class="stringliteral">&quot;A group of Map&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Multimap&quot;</span>), std::string(<span class="stringliteral">&quot;Multimaps are a kind of associative container that stores elements formed by the combination of a key value and a mapped value, much like map containers, but allowing different elements to have the same key value&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Multiset&quot;</span>), std::string(<span class="stringliteral">&quot;Multisets are associative containers with the same properties as set containers, but allowing for multiple keys with equal values&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Set&quot;</span>), std::string(<span class="stringliteral">&quot;Sets are a kind of associative container that stores unique elements, and in which the elements themselves are the keys&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Stack&quot;</span>), std::string(<span class="stringliteral">&quot;Stacks are a type of container adaptor, specifically designed to operate in a LIFO context&quot;</span>)),
            std::make_pair(std::string(<span class="stringliteral">&quot;Vector&quot;</span>), std::string(<span class="stringliteral">&quot;Vectors are a kind of sequence container. As such, their elements are ordered following a strict linear sequence&quot;</span>))
        };


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{

    <span class="keyword">typedef</span> <a name="_a0"></a><a class="code" href="classrtv_1_1_trie.html" title="Trie main class.">rtv::Trie&lt;char, std::string, TrieCaseInsensitiveCompare&gt;</a> Dictionary;
    <span class="keyword">typedef</span> Dictionary::Iterator Iterator;
    <span class="keyword">typedef</span> Dictionary::Iterator ConstIterator;

    Dictionary dictionary(<span class="charliteral">&#39;\0&#39;</span>);

    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <span class="keyword">sizeof</span>(sampleValues) / <span class="keyword">sizeof</span>(sampleValues[0]); ++i) {
        dictionary.insert(sampleValues[i].first.c_str(), sampleValues[i].second);
    }


    <span class="keywordtype">bool</span> finished = <span class="keyword">false</span>;
    <span class="keywordflow">while</span> (!finished) {
        std::cout &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;******************************************&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;0 : To Exit&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;1 : Add a word &quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;2 : Remove a word &quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;3 : Get a word &quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;4 : Search a word (Enter starting letters)&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;5 : List all words &quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;******************************************&quot;</span> &lt;&lt; std::endl;

        std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Enter Choice : &quot;</span>;

        <span class="keywordtype">char</span> c;
        std::cin &gt;&gt; c;
        <span class="keywordflow">switch</span> (c) {
        <span class="keywordflow">case</span> <span class="charliteral">&#39;q&#39;</span>:
        <span class="keywordflow">case</span> <span class="charliteral">&#39;0&#39;</span>: {
            finished = <span class="keyword">true</span>;
            <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">case</span> <span class="charliteral">&#39;1&#39;</span>: {
            <span class="keywordtype">char</span> word[80];
            <span class="keywordtype">char</span> meaning[1024];
            std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the word : &quot;</span>;
            std::cin.ignore();
            std::cin.get(word, <span class="keyword">sizeof</span>(word), <span class="charliteral">&#39;\n&#39;</span>);
            std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the meaning : &quot;</span>;
            std::cin.ignore();
            std::cin.get(meaning, <span class="keyword">sizeof</span>(meaning), <span class="charliteral">&#39;\n&#39;</span>);
            std::pair&lt;Iterator, bool&gt; result = dictionary.insert(&amp;word[0], meaning);
            <span class="keywordflow">if</span> (result.second) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Inserted&quot;</span> &lt;&lt; std::endl;
            } <span class="keywordflow">else</span> {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Insertion failed! key already present&quot;</span> &lt;&lt; std::endl;
                std::cout &lt;&lt; result.first-&gt;first &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; result.first-&gt;second-&gt;c_str() &lt;&lt; std::endl;
            }
            <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">case</span> <span class="charliteral">&#39;2&#39;</span>: {
            <span class="keywordtype">char</span> word[80];
            std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the word : &quot;</span>;
            std::cin.ignore();
            std::cin.get(word, <span class="keyword">sizeof</span>(word), <span class="charliteral">&#39;\n&#39;</span>);
            <span class="keywordflow">if</span> (dictionary.erase(&amp;word[0])) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Removed &quot;</span> &lt;&lt; word &lt;&lt; std::endl;
            } <span class="keywordflow">else</span> {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to Remove &quot;</span> &lt;&lt; word &lt;&lt; std::endl;
            }

            <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">case</span> <span class="charliteral">&#39;3&#39;</span>: {
            <span class="keywordtype">char</span> word[80];
            std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the word : &quot;</span>;
            std::cin.ignore();
            std::cin.get(word, <span class="keyword">sizeof</span>(word), <span class="charliteral">&#39;\n&#39;</span>);

            Iterator iter = dictionary.find(word);
            <span class="keywordflow">if</span> (iter != dictionary.end()) {
                std::cout &lt;&lt; word &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; iter-&gt;second-&gt;c_str() &lt;&lt; std::endl;
            } <span class="keywordflow">else</span> {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find &quot;</span> &lt;&lt; word &lt;&lt; std::endl;
            }
            <span class="keywordflow">break</span>;
        }

        <span class="keywordflow">case</span> <span class="charliteral">&#39;4&#39;</span>: {
            <span class="keywordtype">char</span> word[80];
            std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the word : &quot;</span>;
            std::cin.ignore();
            std::cin.get(word, <span class="keyword">sizeof</span>(word), <span class="charliteral">&#39;\n&#39;</span>);
            std::cout &lt;&lt; <span class="stringliteral">&quot;Searching ... &quot;</span>;

            Iterator iter = dictionary.startsWith(&amp;word[0]);

            <span class="keywordflow">if</span> (iter == dictionary.end()) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find the given word&quot;</span>;
            } <span class="keywordflow">else</span> {
                std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span>;
                <span class="keywordflow">for</span> (; iter != dictionary.end(); ++iter) {
                    std::cout &lt;&lt; std::endl
                              &lt;&lt; iter-&gt;first
                              &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; iter-&gt;second-&gt;c_str();
                }
                std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span>;
            }
            <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">case</span> <span class="charliteral">&#39;5&#39;</span>: {
            std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;
            Iterator iter = dictionary.begin();
            Iterator iend = dictionary.end();

            <span class="keywordflow">for</span> (; iter != iend; ++iter) {
                std::string k((<span class="keyword">const</span> <span class="keywordtype">char</span> *)(iter-&gt;first));

                std::cout.width(10);
                k.insert(0, <span class="stringliteral">&quot;[&quot;</span>);
                k.insert(k.length(), <span class="stringliteral">&quot;]&quot;</span>);
                std::cout &lt;&lt; std::left &lt;&lt; k.c_str() &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>;
                std::cout.width(0);
                std::cout.width(70);
                std::cout &lt;&lt; std::left &lt;&lt; iter-&gt;second-&gt;c_str() &lt;&lt; std::endl;
            }

            std::cout &lt;&lt; <span class="stringliteral">&quot;*****************************************&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">break</span>;
        }
        <span class="keywordflow">default</span>: {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid choice please try again&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">break</span>;
        }
        }
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 13 2012 20:11:00 for Trie by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
